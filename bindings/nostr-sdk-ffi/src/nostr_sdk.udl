// Copyright (c) 2022-2023 Yuki Kishimoto
// Distributed under the MIT software license

namespace nostr_sdk {};

[Error]
interface NostrSdkError {
    Generic(string err);
};

enum LogLevel {
    "Error",
    "Warn",
    "Info",
    "Debug",
    "Trace",
};

// NOSTR

interface ImageDimensions {
    constructor(u64 width, u64 height);
    u64 width();
    u64 height();
};

interface Timestamp {
    [Name=now]
    constructor();
    [Name=from_secs]
    constructor(u64 secs);
    u64 as_secs();
    string to_human_datetime();
};

interface Filter {
    constructor();
    [Self=ByArc]
    Filter id(string id);
    [Self=ByArc]
    Filter ids(sequence<string> ids);
    [Self=ByArc]
    Filter author(string author);
    [Self=ByArc]
    Filter authors(sequence<string> authors);
    [Self=ByArc]
    Filter kind(u64 kind);
    [Self=ByArc]
    Filter kinds(sequence<u64> kinds);
    [Self=ByArc]
    Filter event(EventId event_id);
    [Self=ByArc]
    Filter events(sequence<EventId> ids);
    [Self=ByArc]
    Filter pubkey(PublicKey pubkey);
    [Self=ByArc]
    Filter pubkeys(sequence<PublicKey> pubkeys);
    [Self=ByArc]
    Filter search(string text);
    [Self=ByArc]
    Filter since(Timestamp timestamp);
    [Self=ByArc]
    Filter until(Timestamp timestamp);
    [Self=ByArc]
    Filter limit(u64 limit);
    [Throws=NostrError, Self=ByArc]
    Filter custom_tag(string tag, sequence<string> content);
    [Throws=NostrError, Name=from_json]
    constructor(string json);
    string as_json();
};

interface AccountMetadata {
    constructor();
    [Self=ByArc]
    AccountMetadata name(string name);
    [Self=ByArc]
    AccountMetadata display_name(string display_name);
    [Self=ByArc]
    AccountMetadata about(string about);
    [Throws=NostrError, Self=ByArc]
    AccountMetadata picture(string picture);
    [Self=ByArc]
    AccountMetadata nip05(string nip05);
};

// NOSTR-SDK

interface RelayConnectionStats {
    u64 attempts();
    u64 success();
    u64 connected_at();
};

enum RelayStatus {
    "Initialized",
    "Connected",
    "Connecting",
    "Disconnected",
    "Stopped",
    "Terminated",
};

interface ActiveSubscription {
    string id();
    sequence<Filter> filters();
};

interface Relay {
    string url();
    string? proxy();
    RelayStatus status();
    boolean is_connected();
    RelayInformationDocument document();
    record<DOMString, ActiveSubscription> subscriptions();
    void update_subscription_filters(string internal_id, sequence<Filter> filters);
    RelayConnectionStats stats();
    u64 queue();

    void connect(boolean wait_for_connection);
    [Throws=NostrSdkError]
    void stop();
    [Throws=NostrSdkError]
    void terminate();

    [Throws=NostrSdkError]
    void send_msg(ClientMessage msg, duration? wait);
    [Throws=NostrSdkError]
    void subscribe(sequence<Filter> filters, duration? wait);
    [Throws=NostrSdkError]
    void unsubscribe(duration? wait);

    [Throws=NostrSdkError]
    sequence<Event> get_events_of(sequence<Filter> filters, duration? timeout);
    void req_events_of(sequence<Filter> filters, duration? timeout);
};

interface Options {
    constructor();
    [Self=ByArc]
    Options wait_for_connection(boolean wait);
    [Self=ByArc]
    Options wait_for_send(boolean wait);
    [Self=ByArc]
    Options wait_for_ok(boolean wait);
    [Self=ByArc]
    Options wait_for_subscription(boolean wait);
    [Self=ByArc]
    Options difficulty(u8 difficulty);
    [Self=ByArc]
    Options req_filters_chunk_size(u8 req_filters_chunk_size);
    [Self=ByArc]
    Options timeout(duration? timeout);
    [Self=ByArc]
    Options send_timeout(duration? send_timeout);
    [Self=ByArc]
    Options nip46_timeout(duration? nip46_timeout);
};

interface Client {
    constructor(Keys keys);
    [Name=with_opts]
    constructor(Keys keys, Options opts);

    void update_difficulty(u8 difficulty);
    Keys keys();

    void start();
    [Throws=NostrSdkError]
    void stop();
    boolean is_running();
    [Throws=NostrSdkError]
    void shutdown();
    void clear_already_seen_events();

    record<DOMString, Relay> relays();
    [Throws=NostrSdkError]
    Relay relay(string url);
    [Throws=NostrSdkError]
    void add_relay(string url, optional string? proxy = null);
    [Throws=NostrSdkError]
    void remove_relay(string url);
    [Throws=NostrSdkError]
    void connect_relay(string url);
    [Throws=NostrSdkError]
    void disconnect_relay(string url);
    void connect();
    [Throws=NostrSdkError]
    void disconnect();

    void subscribe(sequence<Filter> filters);
    void unsubscribe();

    [Throws=NostrSdkError]
    sequence<Event> get_events_of(sequence<Filter> filters, duration? timeout);
    void req_events_of(sequence<Filter> filters, duration? timeout);

    [Throws=NostrSdkError]
    void send_msg(ClientMessage msg);
    [Throws=NostrSdkError]
    void send_msg_to(string url, ClientMessage msg);
    [Throws=NostrSdkError]
    EventId send_event(Event event);
    [Throws=NostrSdkError]
    EventId send_event_to(string url, Event event);

    [Throws=NostrSdkError]
    EventId file_metadata(string description, FileMetadata metadata);

    [Self=ByArc]
    void handle_notifications(HandleNotification handler);
};

callback interface HandleNotification {
    void handle_msg(string relay_url, RelayMessage msg);
    void handle(string relay_url, Event event);
};
